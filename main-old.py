import turtle
import sys
import tkinter as tk

#TODO add unit testing
#TODO add benchmarking
#TODO allow nogui usage

################## Tkinter UI setup

###### Buttons Actions
def StartButtonPress():
        startButton["state"] = "disabled"
        StartAlgoDFS(grid_template) #TODO add other algos (and better ones!)

###### Setup the Screen
screen = turtle.Screen()
screen.setup(500,500) #Arbitrary TODO make it dynamic
screen.bgcolor("#888888") #Arbitrary but prevent eye strain TODO make it choosable

###### Create and Place Tkinter UI elements
canvas = screen.getcanvas()
startButton = tk.Button(canvas.master, text="Start", command=StartButtonPress)
canvas.create_window(0, 200, window=startButton) #TODO dynamically place button

################## Turtle Drawing setup
turtle.tracer(False) # turn off tracer to update manually
turtle.speed(0) #draw instanteanously
turtle.hideturtle()
turtle.color("#000000") # grid lines and outline color

###### Start at the upper left Corner
width, height = screen.window_width(), screen.window_height()
offset_x = 10
offset_y = 10
start_x=-width/2 + offset_x #start in the left border (with offset if needed or else it will draw exactly at the border)
start_y=height/2 - offset_y #start in the upper border (with offset if needed or else it will draw exactly at the border)

###### Cell width
cell_width = 50 #TODO make it choosable

###### Color Table : index 0 is the empty space color, 1 is the wall color, 2 is the main car color and >=3 are other cars color
colors = ["#f0f0f0","#000000","red","blue","brown","magenta","green","gold"] #TODO add more colors and possibly make user choose (as it is pretty arbitrary too)

############ Draw the board/grid

###### Draw the grid lines
def DrawBoardLines(width,rows,columns):
    for row in range(0,rows+1):
        turtle.penup()
        turtle.goto(start_x,start_y-row*width)
        turtle.pendown()
        turtle.goto(start_x+rows*width,start_y-row*width)
    for column in range(0,columns+1):
        turtle.penup()
        turtle.goto(start_x+column*width,start_y)
        turtle.pendown()
        turtle.goto(start_x+column*width,start_y-columns*width)

###### Write Coordinate Indicators
def WriteColumnIndicators(width,rows,columns):
    for column in range(0,columns):
        turtle.penup()
        turtle.goto(start_x+column*width+15,start_y-20-rows*width) #TODO make offset explicit
        turtle.write(str(column))
    for row in range(0,rows):
        turtle.penup()
        turtle.goto(start_x+15+columns*width,start_y-row*width+10-width) #TODO make offset explicit
        turtle.write(chr(65+row))

###### Draw filled boxes with outline
def DrawFilledBox(width,color_index):
        turtle.pendown()
        turtle.setheading(0)
        turtle.fillcolor(colors[color_index])
        turtle.begin_fill()
        for i in range(0,4):
            turtle.forward(width)
            turtle.right(90)
        turtle.end_fill()

def DrawBoard(grid,width):
    rows=len(grid)
    columns=len(grid[0]) # granted each row has equal size TODO allow different row sizes

    ## Unnecessary as it is taken care of below when drawing filled boxes but useful to draw empty grid
    #DrawBoardLines(width,rows,columns)

    ## Draw colum indicators TODO make it toggleable by user
    WriteColumnIndicators(width,rows,columns)

    ## Go to starting position
    turtle.penup()
    turtle.goto(start_x,start_y)

    ## Draw each cell with the corresponding color
    for row in range (0,rows):
        for column in range (0,columns):
            if grid[row][column]==-1: #prevent incorrect index access
                DrawFilledBox(width,0) #draw the exit cell with the empty cell color
            else:
                DrawFilledBox(width,grid[row][column])
            ## move to next cell in the row
            turtle.setheading(0)
            turtle.penup()
            turtle.forward(width)
        ## move to the first cell of the next row
        turtle.goto(start_x,start_y-width*(row+1))

################## Setting up the rush hour board

############ Setting up the grid
#TODO make it work better and allow user to choose the desired format
#TODO accept different grid sizes as input (drawing it should work with any size already)
##Set car on the grids manually with -1 the exit, 0 the empty cell, 1 the walls, 2 the main car and >=3 the other cars TODO accept the grid as it is now generated by the listed cars and fails if the grid is not empty (with only empty cells, walls and the exit)
grid = [[1,1,1,1,1,1,1,1]
       ,[1,0,0,3,4,5,6,1]
       ,[1,0,0,3,4,5,6,1]
       ,[1,2,2,3,4,5,6,-1]
       ,[1,0,0,0,0,0,0,1]
       ,[1,0,0,0,0,0,0,1]
       ,[1,0,0,0,0,0,0,1]
       ,[1,1,1,1,1,1,1,1]]

grid_template= [[1,1,1,1,1,1,1,1]
               ,[1,0,0,0,0,0,0,1]
               ,[1,0,0,0,0,0,0,1]
               ,[1,0,0,0,0,0,0,-1]
               ,[1,0,0,0,0,0,0,1]
               ,[1,0,0,0,0,0,0,1]
               ,[1,0,0,0,0,0,0,1]
               ,[1,1,1,1,1,1,1,1]]

##Alternatively, you can list cars TODO deduce cars from grid if needed
cars = []
cars.append({"length":2,"row":3,"column":1,"isHorizontal":True,"color_index":2}) #Main Car (2) TODO make the main car number choosable
cars.append({"length":3,"row":1,"column":3,"isHorizontal":False,"color_index":3})
cars.append({"length":3,"row":1,"column":4,"isHorizontal":False,"color_index":4})
cars.append({"length":3,"row":1,"column":5,"isHorizontal":False,"color_index":5})
cars.append({"length":3,"row":1,"column":6,"isHorizontal":False,"color_index":6})
#TODO allow choosing board size and exit(s) positions as it can't be inputted with current format and uses the grid template

def GenerateGridFromCars(grid, cars):
    for car in cars:
        if car["isHorizontal"]==True:
            for i in range(0,car["length"]):
                grid[car["row"]][car["column"]+i]=car["color_index"]
        else:
            for i in range(0,car["length"]):
                grid[car["row"]+i][car["column"]]=car["color_index"]
    return grid

##TODO accept user friendly format

############ Check if it is solved

###### Find the exit location TODO allow multiple exits
def FindExitGate(grid):
    for cell in grid[0]: #search on the "ceiling"
        if cell==-1:
            return (1,cell)
    for cell in grid[-1]: #search on the "floor"
        if cell==-1:
            return (len(grid)-2,cell)
    for row in range(1,len(grid)-2): #search the "walls" excluding the two previous cases
        if grid[row][0]==-1:
            return (row,1)
        if grid[row][-1]==-1:
            return (row,len(grid[row])-2)

###### Check if the main car is next to the exit
def IsNextToExit(grid):
    x,y = FindExitGate(grid)
    if grid[x][y]==2:
        return True
    else:
        return False

def SerializeGrid(grid):
    serializedGrid = ""
    rows=len(grid)
    columns=len(grid[0]) # granted each row has equal size TODO allow different row sizes
    for row in range (1,rows):
        for column in range (1,columns):
            serializedGrid = serializedGrid + str(grid[row][column])
    #print(serializedGrid)
    return serializedGrid

#Keep history to be able to backtrack if necessary
history = set() #using a set for performance purpose
solution = []
#DFS : Try each possiblity and backtrack when blocked
def DFS_TryCarMove(grid,cars):
        serializedGrid = SerializeGrid(grid)
        if serializedGrid in history:
            return False
        else:
            history.add(serializedGrid)

        for car in cars:
                if car["isHorizontal"]==True: #horizontal car
                        if grid[car["row"]][car["column"]+car["length"]]==0: #if can move right
                            grid[car["row"]][car["column"]]=0
                            grid[car["row"]][car["column"]+car["length"]]=car["color_index"]
                            car["column"]+=1
                            solution.append("Move car {car_number} from ({start_x},{start_y}) to ({goal_x},{goal_y})".format(car_number=car["color_index"],start_x=car["row"],start_y=car["column"]-1,goal_x=car["row"],goal_y=car["column"]))
                            if DFS_TryCarMove(grid,cars)==True:
                                return True
                            #Backtrack
                            car["column"]-=1
                            grid[car["row"]][car["column"]+car["length"]]=0
                            grid[car["row"]][car["column"]]=car["color_index"]
                            solution.pop()

                        if grid[car["row"]][car["column"]-1]==0: #if can move left
                            grid[car["row"]][car["column"]+car["length"]-1]=0
                            grid[car["row"]][car["column"]-1]=car["color_index"]
                            car["column"]-=1
                            solution.append("Move car {car_number} from ({start_x},{start_y}) to ({goal_x},{goal_y})".format(car_number=car["color_index"],start_x=car["row"],start_y=car["column"]+1,goal_x=car["row"],goal_y=car["column"]))
                            if DFS_TryCarMove(grid,cars)==True:
                                return True
                            #Backtrack
                            car["column"]+=1
                            grid[car["row"]][car["column"]-1]=0
                            grid[car["row"]][car["column"]+car["length"]-1]=car["color_index"]
                            solution.pop()
                else: #vertical car
                        if grid[car["row"]+car["length"]][car["column"]]==0: #if can move down
                            grid[car["row"]][car["column"]]=0
                            grid[car["row"]+car["length"]][car["column"]]=car["color_index"]
                            car["row"]+=1
                            solution.append("Move car {car_number} from ({start_x},{start_y}) to ({goal_x},{goal_y})".format(car_number=car["color_index"],start_x=car["row"]-1,start_y=car["column"],goal_x=car["row"],goal_y=car["column"]))
                            if DFS_TryCarMove(grid,cars)==True:
                                return True
                            #Backtrack
                            car["row"]-=1
                            grid[car["row"]+car["length"]][car["column"]]=0
                            grid[car["row"]][car["column"]]=car["color_index"]
                            solution.pop()

                        if grid[car["row"]-1][car["column"]]==0: #if can move up
                            grid[car["row"]+car["length"]-1][car["column"]]=0
                            grid[car["row"]-1][car["column"]]=car["color_index"]
                            car["row"]-=1
                            solution.append("Move car {car_number} from ({start_x},{start_y}) to ({goal_x},{goal_y})".format(car_number=car["color_index"],start_x=car["row"]+1,start_y=car["column"],goal_x=car["row"],goal_y=car["column"]))
                            if DFS_TryCarMove(grid,cars)==True:
                                return True
                            #Backtrack
                            car["row"]+=1
                            grid[car["row"]-1][car["column"]]=0
                            grid[car["row"]+car["length"]-1][car["column"]]=car["color_index"]
                            solution.pop()

                DrawBoard(grid,cell_width)
                turtle.update()

                if IsNextToExit(grid):
                    print("Solution found !")
                    #TODO move the car outside :
                        #DrawBoard(grid,cell_width)
                        #turtle.update()
                    return True
        return False

################## The start of the algorithm !
def StartAlgoDFS(grid):
    grid=Setup(grid,cars)
    print(grid)
    print("\n\n")
    if DFS_TryCarMove(grid,cars):
        for line in solution:
            print(line)
        print("\n\n")
        print(grid)
        sys.exit("Solved!") #TODO show solution steps
    else:
        sys.exit("Can't' be solved!")

################## Setup all things needed before starting
def Setup(grid,cars):
    grid=GenerateGridFromCars(grid,cars)
    DrawBoard(grid,cell_width)
    turtle.update()
    return grid

Setup(grid,cars) #to show the grid at startup without any user interaction probably can do better

#Tkinter way to not close the window (equivalent to while(true))
screen.mainloop()